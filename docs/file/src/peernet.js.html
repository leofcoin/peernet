<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/peernet.js | @leofcoin/peernet</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/client.js~PeernetClient.html">PeernetClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/peer-info.js~PeerInfo.html">PeerInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/peer.js~PeernetPeer.html">PeernetPeer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/peernet.js~Peernet.html">Peernet</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#codec">codec</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/codec/codec.js~PeernetCodec.html">PeernetCodec</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#dht">dht</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dht/dht.js~DhtEarth.html">DhtEarth</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#discovery">discovery</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/discovery/peer-discovery.js~PeerDiscovery.html">PeerDiscovery</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors">errors</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dhtError">dhtError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-encapsulatedError">encapsulatedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nothingFoundError">nothingFoundError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#handlers">handlers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/handlers/message.js~MessageHandler.html">MessageHandler</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#hash">hash</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/hash/hash.js~PeernetHash.html">PeernetHash</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#http">http</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-http">http</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#http-client">http/client</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/http/client/api.js~api.html">api</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/http/client/http-client.js~HttpClientApi.html">HttpClientApi</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/http/client/storage.js~LeofcoinStorageClient.html">LeofcoinStorageClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-client">client</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#messages">messages</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/chat-message.js~ChatMessage.html">ChatMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/data-response.js~DataMessageResponse.html">DataMessageResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/data.js~DataMessage.html">DataMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/dht-response.js~DHTMessageResponse.html">DHTMessageResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/dht.js~DHTMessage.html">DHTMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/peer-response.js~PeerMessageResponse.html">PeerMessageResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/peer.js~PeerMessage.html">PeerMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/peernet-message.js~PeernetMessage.html">PeernetMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/ps.js~PsMessage.html">PsMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/request.js~RequestMessage.html">RequestMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/messages/response.js~ResponseMessage.html">ResponseMessage</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-debug">debug</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-environment">environment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-expected">expected</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hasDaemon">hasDaemon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-https">https</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-protoFor">protoFor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-target">target</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/peernet.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Pubsub from &apos;@vandeurenglenn/little-pubsub&apos;
import Client from &apos;./client&apos;
import LeofcoinStorage from &apos;@leofcoin/storage&apos;
import http from &apos;./http/http.js&apos;
import httpClient from &apos;./http/client/client.js&apos;
import LeofcoinStorageClient from &apos;./http/client/storage.js&apos;
import PeernetMessage from &apos;./messages/peernet-message.js&apos;
import DHTMessage from &apos;./messages/dht.js&apos;
import DHTMessageResponse from &apos;./messages/dht-response.js&apos;
import DataMessage from &apos;./messages/data.js&apos;
import PsMessage from &apos;./messages/ps.js&apos;
import PeerMessage from &apos;./messages/peer.js&apos;
import RequestMessage from &apos;./messages/request.js&apos;
import ResponseMessage from &apos;./messages/response.js&apos;
import PeerMessageResponse from &apos;./messages/peer-response.js&apos;
import DataMessageResponse from &apos;./messages/data-response.js&apos;
import ChatMessage from &apos;./messages/chat-message.js&apos;
import PeerDiscovery from &apos;./discovery/peer-discovery&apos;
import DHT from &apos;./dht/dht.js&apos;
import Hash from &apos;./hash/hash&apos;
import codecs from &apos;./codec/codecs&apos;
import { debug, protoFor, target } from &apos;./utils/utils.js&apos;
import generateAccount from
  &apos;./../node_modules/@leofcoin/generate-account/dist/module/generate-account.js&apos;
import MessageHandler from &apos;./handlers/message.js&apos;
import { encapsulatedError, dhtError,
  nothingFoundError } from &apos;./errors/errors.js&apos;

globalThis.leofcoin = globalThis.leofcoin || {}
globalThis.globalSub = globalThis.globalSub || new Pubsub({verbose: true})

/**
 * @access public
 * @example
 * const peernet = new Peernet();
 */
export default class Peernet {
  /**
   * @access public
   * @param {Object} options
   * @param {String} options.network - desired network
   * @param {String} options.root - path to root directory
   * @param {String} options.storePrefix - prefix for datatores (lfc)
   *
   * @return {Promise} instance of Peernet
   *
   * @example
   * const peernet = new Peernet({network: &apos;leofcoin&apos;, root: &apos;.leofcoin&apos;});
   */
  constructor(options = {}) {
    this._discovered = []
    /**
     * @property {String} network - current network
     */
    this.network = options.network || &apos;leofcoin&apos;
    const parts = this.network.split(&apos;:&apos;)

    if (!options.storePrefix) options.storePrefix = &apos;lfc&apos;
    if (!options.port) options.port = 2000
    if (!options.root) {
      if (parts[1]) options.root = `.${parts[0]}/peernet/${parts[1]}`
      else options.root = `.${this.network}/peernet`
    }
    globalThis.peernet = this
    this.bw = {
      up: 0,
      down: 0,
    }
    return this._init(options)
  }

  get defaultStores() {
    return [&apos;account&apos;, &apos;wallet&apos;, &apos;block&apos;, &apos;transaction&apos;, &apos;chain&apos;, &apos;data&apos;, &apos;message&apos;]
  }

  addProto(name, proto) {
    if (!this.protos[name]) this.protos[name] = proto
  }

  addCodec(name, codec) {
    if (!this.codecs[name]) this.codecs[name] = codec
  }

  async addStore(name, prefix, root, isPrivate = true) {
    if (name === &apos;block&apos; || name === &apos;transaction&apos; || name === &apos;chain&apos; ||
        name === &apos;data&apos; || name === &apos;message&apos;) isPrivate = false

    let Storage
    if (this.hasDaemon) {
      Storage = LeofcoinStorageClient
    } else {
      Storage = LeofcoinStorage
    }
    globalThis[`${name}Store`] = globalThis[`${name}Store`] ||
      await new Storage(`${prefix}-${name}`, root)

    globalThis[`${name}Store`].private = isPrivate
    if (!isPrivate) this.stores.push(name)
  }


  /**
   * @see MessageHandler
   */
  prepareMessage(to, data) {
    return this._messageHandler.prepareMessage(this.id, to, data)
  }

  /**
   * @access public
   *
   * @return {Array} peerId
   */
  get peers() {
    return [...connections.values()]
  }

  /**
   * @private
   *
   * @param {Object} options
   * @param {String} options.root - path to root directory
   *
   * @return {Promise} instance of Peernet
   */
  async _init(options) {
    // peernetDHT aka closesPeer by coordinates
    /**
     * @type {Object}
     * @property {Object} peer Instance of Peer
     */
    this.dht = new DHT()
    /**
     * @type {Map}
     * @property {Object} peer Instance of Peer
     */
    this.peerMap = new Map()
    this.stores = []
    this.requestProtos = {}
    this.storePrefix = options.storePrefix
    this.root = options.root

    /**
     * proto Object containing protos
     * @type {Object}
     * @property {PeernetMessage} protos[peernet-message] messageNode
     * @property {DHTMessage} protos[peernet-dht] messageNode
     * @property {DHTMessageResponse} protos[peernet-dht-response] messageNode
     * @property {DataMessage} protos[peernet-data] messageNode
     * @property {DataMessageResponse} protos[peernet-data-response] messageNode
     */
    globalThis.peernet.protos = {
      &apos;peernet-request&apos;: RequestMessage,
      &apos;peernet-response&apos;: ResponseMessage,
      &apos;peernet-peer&apos;: PeerMessage,
      &apos;peernet-peer-response&apos;: PeerMessageResponse,
      &apos;peernet-message&apos;: PeernetMessage,
      &apos;peernet-dht&apos;: DHTMessage,
      &apos;peernet-dht-response&apos;: DHTMessageResponse,
      &apos;peernet-data&apos;: DataMessage,
      &apos;peernet-data-response&apos;: DataMessageResponse,
      &apos;peernet-ps&apos;: PsMessage,
      &apos;chat-message&apos;: ChatMessage,
    }

    this.protos = globalThis.peernet.protos
    this.codecs = codecs

    this._messageHandler = new MessageHandler(this.network)

    const {daemon, environment} = await target()
    this.hasDaemon = daemon

    if (this.hasDaemon) {
      globalThis.peernet.client = await httpClient({
        protocol: &apos;peernet-v0.1.0&apos;, host: &apos;127.0.0.1&apos;, port: options.port,
      })
    } else {
      if (environment !== &apos;browser&apos;) http(options)
    }

    for (const store of this.defaultStores) {
      await this.addStore(store, options.storePrefix, options.root)
    }

    try {
      const pub = await accountStore.get(&apos;public&apos;)
      this.id = pub.walletId
    } catch (e) {
      if (e.code === &apos;ERR_NOT_FOUND&apos;) {
        const wallet = {}
        const {identity, accounts, config} = await generateAccount(this.network)
        wallet.identity = identity
        wallet.accounts = accounts
        wallet.version = 1
        walletStore.put(wallet)
        await accountStore.put(&apos;config&apos;, config);
        await accountStore.put(&apos;public&apos;, {walletId: wallet.identity.walletId});

        this.id = wallet.identity.walletId
      } else {
        throw e
      }
    }
    this._peerHandler = new PeerDiscovery(this.id)
    // peernet id
    const id = Buffer.from(this.id.slice(0, 32))
    this.peerId = id

    pubsub.subscribe(&apos;peer:discovered&apos;, async (peer) =&gt; {
      peer.on(&apos;peernet.data&apos;, async (message) =&gt; {
        const id = message.id;
        message = new PeernetMessage(Buffer.from(message.data.data));
        const proto = protoFor(message.decoded.data);
        await this._protoHandler({id, proto}, peer);
      });
      await this._peerHandler.discover(peer);
      const fulldId = this._getPeerId(peer.id);
      if (fulldId &amp;&amp; this._discovered.indexOf(peer.id) === -1) {
        this._discovered.push(peer.id);
        pubsub.publish(&apos;peer:connected&apos;, peer);
      }
    });
    pubsub.subscribe(&apos;peer:disconnected&apos;, async (peer) =&gt; {
      let index = this._discovered.indexOf(peer.id)
      if (index !== -1) this._discovered.splice(index, 1)
      const id = this._getPeerId(peer.id)
      let peerIds = this.peerMap.get(id)

      if (peerIds) {
        index = peerIds.indexOf(peer.id)
        if (index !== -1) peerIds.splice(index, 1)
      } else {
        peerIds = []
      }

      if (peerIds.length === 0) this.peerMap.delete(id)
      else this.peerMap.set(id, peerIds)
    })
    pubsub.subscribe(&apos;peer:connected&apos;, async (peer) =&gt; {
      console.log({connected: peer.id, as: this._getPeerId(peer.id) });
      // peer.on(&apos;peernet.data&apos;, async (message) =&gt; {
      //   const id = message.id
      //   message = new PeernetMessage(Buffer.from(message.data.data))
      //   const proto = protoFor(message.decoded.data)
      //   this._protoHandler({id, proto}, peer)
      // })
    })

    /**
     * @access public
     * @type {PeernetClient}
     */
    this.client = new Client({...options, id})
    if (globalThis.onbeforeunload) {
      globalThis.addEventListener(&apos;beforeunload&apos;, async () =&gt; this.client.close());
    }
    return this
  }

  _getPeerId(id) {
    for (const entry of [...this.peerMap.entries()]) {
      for (const _id of entry[1]) {
        if (_id === id) return entry[0]
      }
    }
  }

  addRequestHandler(name, method) {
    this.requestProtos[name] = method
  }

  /**
   * @private
   *
   * @param {Buffer} message - peernet message
   * @param {PeernetPeer} peer - peernet peer
   */
  async _protoHandler(message, peer) {
    const {id, proto} = message
    this.bw.down += proto.encoded.length
    if (proto.name === &apos;peernet-peer&apos;) {
      const from = proto.decoded.id
      if (!this.peerMap.has(from)) this.peerMap.set(from, [peer.id])
      else {
        const connections = this.peerMap.get(from)
        if (connections.indexOf(peer.id) === -1) {
          connections.push(peer.id)
          this.peerMap.set(from, connections)
        }
      }
      const data = new PeerMessageResponse({id: this.id})
      const node = await this.prepareMessage(from, data.encoded)

      peer.write(Buffer.from(JSON.stringify({id, data: node.encoded})))
      this.bw.up += node.encoded.length
    } else if (proto.name === &apos;peernet-peer-response&apos;) {
      const from = proto.decoded.id
      if (!this.peerMap.has(from)) this.peerMap.set(from, [peer.id])
      else {
        const connections = this.peerMap.get(from)
        if (connections.indexOf(peer.id) === -1) {
          connections.push(peer.id)
          this.peerMap.set(from, connections)
        }
      }
    } else {
      let from = this._getPeerId(peer.id)
      if (!from) {
        const data = new PeerMessage({id: this.id})
        const node = await this.prepareMessage(peer.id, data.encoded)
        this.bw.up += node.encoded.length
        let response = await peer.request(node.encoded)
        response = protoFor(response)

        response = new PeerMessageResponse(response.decoded.data)

        from = response.decoded.id
        if (!this.peerMap.has(from)) this.peerMap.set(from, [peer.id])
        else {
          const connections = this.peerMap.get(from)
          if (connections.indexOf(peer.id) === -1) {
            connections.push(peer.id)
            this.peerMap.set(from, connections)
          }
        }
      }
      if (proto.name === &apos;peernet-dht&apos;) {
        let { hash, store } = proto.decoded
        let has;

        if (!store) {
          has = await this.has(hash)
        } else {
          store = globalThis[`${store}Store`]
          if (store.private) has = false
          else has = await store.has(hash)
        }
        const data = new DHTMessageResponse({hash, has})
        const node = await this.prepareMessage(from, data.encoded)

        peer.write(Buffer.from(JSON.stringify({id, data: node.encoded})))
        this.bw.up += node.encoded.length
      } else if (proto.name === &apos;peernet-data&apos;) {
        let { hash, store } = proto.decoded
        let data

        if (!store) {
          data = await this.get(hash)
        } else {
          store = globalThis[`${store}Store`]
          if (store.private) {
            // TODO: ban
            return
          } else data = await store.get(hash)
        }

        if (data) {
          data = new DataMessageResponse({hash, data: data.decoded ? Buffer.from(JSON.stringify(data)) : Buffer.from(data)});

          const node = await this.prepareMessage(from, data.encoded)
          peer.write(Buffer.from(JSON.stringify({id, data: node.encoded})))
          this.bw.up += node.encoded.length
        }
      } else if (proto.name === &apos;peernet-peer&apos;) {
        const from = proto.decoded.id
        if (!this.peerMap.has(from)) this.peerMap.set(from, [peer.id])
        else {
          const connections = this.peerMap.get(from)
          connections.push(peer.id)
          this.peerMap.set(from, connections)
        }
        const data = new PeerMessage({id: this.id})
        const node = await this.prepareMessage(from, data.encoded)

        peer.write(Buffer.from(JSON.stringify({id, data: node.encoded})))
        this.bw.up += node.encoded.length
      } else if (proto.name === &apos;peernet-request&apos;) {
        // TODO: make dynamic
        // exposeddevapi[proto.decoded.request](proto.decoded.params)
        const method = this.requestProtos[proto.decoded.request]
        if (method) {
          const data = await method()
          const node = await this.prepareMessage(from, data.encoded)
          peer.write(Buffer.from(JSON.stringify({id, data: node.encoded})))
          this.bw.up += node.encoded.length
        }
      } else if (proto.name === &apos;peernet-ps&apos; &amp;&amp;
                 this._getPeerId(peer.id) !== this.id.toString()) {
        globalSub.publish(proto.decoded.topic.toString(), proto.decoded.data.toString())
      }
    }
  }

  /**
   * performs a walk and resolves first encounter
   *
   * @param {String} hash
   */
  async walk(hash) {
    if (!hash) throw new Error(&apos;hash expected, received undefined&apos;)
    const data = new DHTMessage({hash})
    const clientId = this.client.id
    for (const peer of this.peers) {
      const node = await this.prepareMessage(peer.id, data.encoded)

      const result = await peer.request(node.encoded)

      let proto = protoFor(result.data)

      if (proto.name !== &apos;peernet-message&apos;) throw encapsulatedError()
      const from = proto.decoded.from
      proto = protoFor(proto.decoded.data)

      if (proto.name !== &apos;peernet-dht-response&apos;) throw dhtError(proto.name)

      // TODO: give ip and port (just used for location)
      if (!peer.connection.remoteAddress || !peer.connection.localAddress) {
        peer.connection.remoteFamily = &apos;ipv4&apos;
        peer.connection.remoteAddress = &apos;127.0.0.1&apos;
        peer.connection.remotePort = &apos;0000&apos;
      }

      const peerInfo = {
        family: peer.connection.remoteFamily || peer.connection.localFamily,
        address: peer.connection.remoteAddress || peer.connection.localAddress,
        port: peer.connection.remotePort || peer.connection.localPort,
        id: from,
      }

      if (proto.decoded.has) this.dht.addProvider(peerInfo, proto.decoded.hash)
    }
    return
  }

  /**
   * Override DHT behavior, try&apos;s finding the content three times
   *
   * @param {String} hash
   */
  async providersFor(hash) {
    let providers = await this.dht.providersFor(hash)
    // walk the network to find a provider
    if (!providers || providers.length === 0) {
      await this.walk(hash)
      providers = await this.dht.providersFor(hash)
      // second walk the network to find a provider
      if (!providers || providers.length === 0) {
        await this.walk(hash)
        providers = await this.dht.providersFor(hash)
      }
      // last walk
      if (!providers || providers.length === 0) {
        await this.walk(hash)
        providers = await this.dht.providersFor(hash)
      }
    }
    // undefined if no providers given
    return providers
  }

  get block() {
    return {
      get: async (hash) =&gt; {
        const data = await blockStore.has(hash)
        if (data) return await blockStore.get(hash)
        return this.requestData(hash)
      },
      put: async (hash, data) =&gt; {
        if (await blockStore.has(hash)) return
        return await blockStore.put(hash, data)
      },
      has: async (hash) =&gt; await blockStore.has(hash, &apos;block&apos;),
    }
  }

  get transaction() {
    return {
      get: async (hash) =&gt; {
        const data = await transactionStore.has(hash)
        if (data) return await transactionStore.get(hash)
        return this.requestData(hash, &apos;transaction&apos;)
      },
      put: async (hash, data) =&gt; {
        if (await transactionStore.has(hash)) return
        return await transactionStore.put(hash, data)
      },
      has: async (hash) =&gt; await transactionStore.has(hash),
    }
  }

  async requestData(hash, store) {
    const providers = await this.providersFor(hash)
    if (!providers || providers.size === 0) throw nothingFoundError(hash)
    debug(`found ${providers.size} provider(s) for ${hash}`)
    // get closest peer on earth
    const closestPeer = await this.dht.closestPeer(providers)
    // get peer instance by id
    if (!closestPeer || !closestPeer.id) return this.requestData(hash, store)

    const id = closestPeer.id.toString()
    if (this.peers) {
      let closest = this.peers.filter((peer) =&gt; {
        if (this._getPeerId(peer.id) === id) return peer
      })

      let data = new DataMessage({hash, store})

      const node = await this.prepareMessage(id, data.encoded)
      if (closest[0]) data = await closest[0].request(node.encoded)
      else {
        closest = this.peers.filter((peer) =&gt; {
          if (peer.id.toString() === id) return peer
        })
        if (closest[0]) data = await closest[0].request(node.encoded)
      }
      if (data.data) {
        let proto = protoFor(Buffer.from(data.data))
        proto = protoFor(proto.decoded.data)
        return proto.decoded.data
      }

      // this.put(hash, proto.decoded.data)
    }
    return null
  }


  get message() {
    return {
      /**
       * Get content for given message hash
       *
       * @param {String} hash
       */
      get: async (hash) =&gt; {
        debug(`get message ${hash}`)
        const message = await messageStore.has(hash)
        if (message) return await messageStore.get(hash)
        return this.requestData(hash, &apos;message&apos;)
      },
      /**
       * put message content
       *
       * @param {String} hash
       * @param {Buffer} message
       */
      put: async (hash, message) =&gt; await messageStore.put(hash, message),
      /**
       * @param {String} hash
       * @return {Boolean}
       */
      has: async (hash) =&gt; await messageStore.has(hash),
    }
  }

  get data() {
    return {
      /**
       * Get content for given data hash
       *
       * @param {String} hash
       */
      get: async (hash) =&gt; {
        debug(`get data ${hash}`)
        const data = await dataStore.has(hash)
        if (data) return await dataStore.get(hash)
        return this.requestData(hash, &apos;data&apos;)
      },
      /**
       * put data content
       *
       * @param {String} hash
       * @param {Buffer} data
       */
      put: async (hash, data) =&gt; await dataStore.put(hash, data),
      /**
       * @param {String} hash
       * @return {Boolean}
       */
      has: async (hash) =&gt; await dataStore.has(hash),
    }
  }

  /**
   * goes trough given stores and tries to find data for given hash
   * @param {Array} stores
   * @param {string} hash
   */
  async whichStore(stores, hash) {
    let store = stores.pop()
    const name = store
    store = globalThis[`${store}Store`]
    if (store) {
      const has = await store.has(hash)
      if (has) return store
      if (stores.length &gt; 0) return this.whichStore(stores, hash)
    } else return null
  }

  /**
   * Get content for given hash
   *
   * @param {String} hash
   */
  async get(hash, store) {
    debug(`get ${hash}`)
    let data
    if (store) store = globalThis[`${store}Store`]
    if (!store) store = await this.whichStore([...this.stores], hash)
    if (store &amp;&amp; await store.has(hash)) data = await store.get(hash)
    if (data) return data

    return this.requestData(hash, &apos;data&apos;)
  }

  /**
   * put content
   *
   * @param {String} hash
   * @param {Buffer} data
   */
  async put(hash, data, store = &apos;data&apos;) {
    store = globalThis[`${store}Store`]
    return await store.put(hash, data)
  }

  /**
   * @param {String} hash
   * @return {Boolean}
   */
  async has(hash) {
    const store = await this.whichStore([...this.stores], hash)
    if (store) {
      if (store.private) return false
      else return true
    }
    return false
  }

  /**
   *
   * @param {String} topic
   * @param {String|Object|Array|Boolean|Buffer} data
   */
  async publish(topic, data) {
    // globalSub.publish(topic, data)
    if (!Buffer.isBuffer(topic)) topic = Buffer.from(topic)
    if (!Buffer.isBuffer(data)) data = Buffer.from(data)
    const id = Math.random().toString(36).slice(-12)
    data = new PsMessage({data, topic})
    for (const peer of this.peers) {
      if (peer.connection._connected) {
        if (peer.id.toString() !== this.peerId.toString()) {
          const node = await this.prepareMessage(peer.id, data.encoded)
          peer.write(Buffer.from(JSON.stringify({id, data: node.encoded})))
        }
      } else {
        this.removePeer(peer)
      }
      // TODO: if peer subscribed
    }
  }

  createHash(data, name) {
    return new Hash(data, {name})
  }

  /**
   *
   * @param {String} topic
   * @param {Method} cb
   */
  async subscribe(topic, cb) {
    // TODO: if peer subscribed
    globalSub.subscribe(topic, cb)
  }

  async removePeer(peer) {
    connections.delete(peer.id)
  }

  get Buffer() {
    return Buffer
  }
  // async block(index) {
  //   const _values = []
  //   for (const peer of this.peers) {
  //     const value = await peer.request({type: &apos;block&apos;, index})
  //     console.log(value);
  //   }
  //
  // }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
